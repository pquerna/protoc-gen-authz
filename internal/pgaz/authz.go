package pgaz

import (
	"bytes"
	"fmt"
	"regexp"
	"sort"
	"strings"

	"github.com/pquerna/protoc-gen-authz/authz"

	"github.com/dave/jennifer/jen"
	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
)

const (
	moduleName    = "authz"
	version       = "0.1.0"
	commentFormat = `// Code generated by protoc-gen-%s v%s. DO NOT EDIT.
// source: %s
`
)

const (
	authzPkg = "github.com/pquerna/protoc-gen-authz/authz"
)

type Module struct {
	*pgs.ModuleBase
	ctx pgsgo.Context

	initStatements []jen.Code
}

var _ pgs.Module = (*Module)(nil)

func New() pgs.Module {
	return &Module{ModuleBase: &pgs.ModuleBase{}, initStatements: make([]jen.Code, 0)}
}

func (m *Module) InitContext(ctx pgs.BuildContext) {
	m.ModuleBase.InitContext(ctx)
	m.ctx = pgsgo.InitContext(ctx.Parameters())
}

func (m *Module) Name() string {
	return moduleName
}

func (m *Module) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	for _, f := range targets {
		msgs := f.Services()
		if n := len(msgs); n == 0 {
			m.Debugf("No services in %v, skipping", f.Name())
			continue
		}
		m.processFile(f)
	}
	return m.Artifacts()
}

func (m *Module) processFile(f pgs.File) {
	// NOTE: this code is poorly structured.  initStatements persists across processing of a single file.
	m.initStatements = make([]jen.Code, 0)
	out := bytes.Buffer{}
	err := m.applyTemplate(&out, f)
	if err != nil {
		m.Logf("couldn't apply template: %s", err)
		m.Fail("code generation failed")
	} else {
		generatedFileName := m.ctx.OutputPath(f).SetExt(fmt.Sprintf(".%s.go", moduleName)).String()
		m.AddGeneratorFile(generatedFileName, out.String())
	}
}

func (m *Module) applyTemplate(buf *bytes.Buffer, in pgs.File) error {
	pkgName := m.ctx.PackageName(in).String()
	importPath := m.ctx.ImportPath(in).String()
	protoFileName := in.Name().String()

	f := jen.NewFilePathName(importPath, pkgName)
	f.HeaderComment(fmt.Sprintf(commentFormat, moduleName, version, protoFileName))

	f.ImportName(authzPkg, "authz")

	for _, service := range in.Services() {
		serviceOpts := &authz.ServiceOptions{}
		ok, err := service.Extension(authz.E_Service, serviceOpts)
		if err != nil {
			return err
		}
		if ok && serviceOpts.Disabled {
			continue
		}
		err = m.applyService(f, service)
		if err != nil {
			return err
		}
	}

	for _, message := range in.AllMessages() {
		messageOptions := &authz.MessageOptions{}
		ok, err := message.Extension(authz.E_Message, messageOptions)
		if err != nil {
			return err
		}
		if !ok {
			continue
		}
		err = m.applyMessage(f, message, messageOptions)
		if err != nil {
			return err
		}
	}

	f.Func().Id("init").Params().Block(
		m.initStatements...,
	)
	return f.Render(buf)
}

func roleName(service pgs.Service, rn string) string {
	return fmt.Sprintf("role/%s.%s:%s", service.Package().ProtoName().String(), service.Name().String(), strings.ToLower(rn))
}

func permissionName(service pgs.Service, method pgs.Method) string {
	return fmt.Sprintf("permission/%s.%s.%s", service.Package().ProtoName().String(), service.Name().String(), method.Name().String())
}

func messageRoleName(message pgs.Message, customRole string) string {
	return fmt.Sprintf("role/%s.%s.%s", message.Package().ProtoName().String(), message.Name().String(), customRole)
}
func messagePermName(message pgs.Message, customRole string) string {
	return fmt.Sprintf("permission/%s.%s.%s", message.Package().ProtoName().String(), message.Name().String(), customRole)
}

var reIdentifier = regexp.MustCompile("[[:^alnum:]]")

type Vars struct {
	group     string
	name      string
	statement *jen.Statement
}

type VarsSorter []*Vars

func (a VarsSorter) Len() int      { return len(a) }
func (a VarsSorter) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
func (a VarsSorter) Less(i, j int) bool {
	if a[i].group != a[j].group {
		return a[i].group < a[j].group
	}
	return a[i].name < a[j].name
}

func (m *Module) applyMessage(f *jen.File, message pgs.Message, options *authz.MessageOptions) error {
	if options.CustomRole == "" {
		return nil
	}
	// make perm
	varName := pgs.Name(message.Name().String() + pgs.Name(options.CustomRole).UpperCamelCase().String() + "Permission").UpperCamelCase().String()
	permName := messagePermName(message, options.CustomRole)
	statement := jen.Id(varName).Op("=").Qual(authzPkg, "RegisterPermission").Call(jen.Lit(permName))

	// make role
	roleName := pgs.Name(message.Name().String() + pgs.Name(options.CustomRole).UpperCamelCase().String() + "Permission").UpperCamelCase().String()

	f.Var().Defs(statement)
	jen.Qual(authzPkg, "RegisterRole").Call(jen.Id(permName))

	// for _, k := range roleToPermissionsKeys {
	// 	permIds := []jen.Code{}
	// 	for _, perm := range roleToPermissions[k] {
	// 		permIds = append(permIds, jen.Id(perm).Dot("ID"))
	// 	}
	// m.initStatements = append(m.initStatements,
	// 	jen.Qual(authzPkg, "RegisterRole").Call(jen.Id(varName),
	// 		jen.Op("[]").Qual(authzPkg, "PermissionId").Values(permIds...),
	// 	),
	// )

	return nil
}
func (m *Module) applyService(f *jen.File, service pgs.Service) error {
	variables := map[string]*Vars{}
	roleToPermissions := map[string][]string{}
	roleNames := map[authz.Roles]string{}
	for roleId := authz.Roles_UNKNOWN + 1; roleId <= authz.Roles_OWNER; roleId++ {
		roleTitle := strings.Title(strings.ToLower(roleId.String()))
		roleStringValue := roleName(service, roleId.String())
		varName := pgs.Name(service.Name().String() + pgs.Name(roleTitle).UpperCamelCase().String() + "Role").UpperCamelCase().String()
		variables[varName] = &Vars{
			group:     "roles",
			name:      varName,
			statement: jen.Id(varName).Op("=").Lit(roleStringValue),
		}
		roleNames[roleId] = varName
	}

	for _, method := range service.Methods() {
		methodOptions := &authz.MethodOptions{}
		ok, err := method.Extension(authz.E_Method, methodOptions)
		if err != nil {
			return err
		}
		if !ok {
			return fmt.Errorf("%s: Missing authz.method annotation: Add authz.service.Disabled=true if authz is not desired for a Service", method.FullyQualifiedName())
		}
		if len(methodOptions.CustomRoles) == 0 && methodOptions.Role == authz.Roles_UNKNOWN {
			return fmt.Errorf("%s: authz.method annotation: Must set role or custom_roles", method.FullyQualifiedName())
		}

		permVarName := pgs.Name(service.Name().String() + method.Name().UpperCamelCase().String() + "Permission").UpperCamelCase().String()
		permName := permissionName(service, method)
		variables[permVarName] = &Vars{
			group:     "permissions",
			name:      permVarName,
			statement: jen.Id(permVarName).Op("=").Qual(authzPkg, "RegisterPermission").Call(jen.Lit(permName)),
		}

		for _, cr := range methodOptions.CustomRoles {
			cr = reIdentifier.ReplaceAllLiteralString(cr, "_")
			rn := roleName(service, cr)
			varName := pgs.Name(service.Name().String() + pgs.Name(cr).UpperCamelCase().String() + "Role").UpperCamelCase().String()
			variables[varName] = &Vars{
				group:     "roles",
				name:      varName,
				statement: jen.Id(varName).Op("=").Lit(rn),
			}
			roleToPermissions[varName] = append(roleToPermissions[varName], permVarName)
		}

		switch methodOptions.Role {
		case authz.Roles_UNKNOWN:
			// custom role only, add to owner
			roleToPermissions[roleNames[authz.Roles_OWNER]] = append(roleToPermissions[roleNames[authz.Roles_OWNER]], permVarName)
		case authz.Roles_REFLECTION:
			roleToPermissions[roleNames[authz.Roles_REFLECTION]] = append(roleToPermissions[roleNames[authz.Roles_REFLECTION]], permVarName)
			roleToPermissions[roleNames[authz.Roles_VIEWER]] = append(roleToPermissions[roleNames[authz.Roles_VIEWER]], permVarName)
			roleToPermissions[roleNames[authz.Roles_EDITOR]] = append(roleToPermissions[roleNames[authz.Roles_EDITOR]], permVarName)
			roleToPermissions[roleNames[authz.Roles_OWNER]] = append(roleToPermissions[roleNames[authz.Roles_OWNER]], permVarName)
		case authz.Roles_VIEWER:
			roleToPermissions[roleNames[authz.Roles_VIEWER]] = append(roleToPermissions[roleNames[authz.Roles_VIEWER]], permVarName)
			roleToPermissions[roleNames[authz.Roles_EDITOR]] = append(roleToPermissions[roleNames[authz.Roles_EDITOR]], permVarName)
			roleToPermissions[roleNames[authz.Roles_OWNER]] = append(roleToPermissions[roleNames[authz.Roles_OWNER]], permVarName)
		case authz.Roles_EDITOR:
			roleToPermissions[roleNames[authz.Roles_EDITOR]] = append(roleToPermissions[roleNames[authz.Roles_EDITOR]], permVarName)
			roleToPermissions[roleNames[authz.Roles_OWNER]] = append(roleToPermissions[roleNames[authz.Roles_OWNER]], permVarName)
		case authz.Roles_OWNER:
			roleToPermissions[roleNames[authz.Roles_OWNER]] = append(roleToPermissions[roleNames[authz.Roles_OWNER]], permVarName)
		default:
			panic("Unknown built in role: update protoc-gen-authz!")
		}
		structName := m.ctx.Name(method.Input())
		f.Func().Params(
			jen.Id("p").Op("*").Id(structName.String()),
		).Id("AuthzRequiresPermission").Params().Params(jen.Qual(authzPkg, "PermissionId")).Block(
			jen.Return(jen.Id(permVarName).Dot("ID")),
		).Line()
	}

	clist := make([]*Vars, 0, len(variables))
	for _, c := range variables {
		clist = append(clist, c)
	}
	sort.Sort(VarsSorter(clist))
	statements := []jen.Code{}
	grouping := ""
	for _, c := range clist {
		if c.group != grouping {
			statements = append(statements, jen.Line())
			grouping = c.group
		}
		statements = append(statements, c.statement)
	}
	f.Var().Defs(statements...)

	roleToPermissionsKeys := make([]string, 0, len(roleToPermissions))
	for k, _ := range roleToPermissions {
		roleToPermissionsKeys = append(roleToPermissionsKeys, k)
	}
	sort.Strings(roleToPermissionsKeys)
	for _, k := range roleToPermissionsKeys {
		permIds := []jen.Code{}
		for _, perm := range roleToPermissions[k] {
			permIds = append(permIds, jen.Id(perm).Dot("ID"))
		}
		m.initStatements = append(m.initStatements,
			jen.Qual(authzPkg, "RegisterRole").Call(jen.Id(k),
				jen.Op("[]").Qual(authzPkg, "PermissionId").Values(permIds...),
			),
		)
	}
	return nil
}
